{"version":3,"file":"static/js/284.6a103135.chunk.js","mappings":"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","sources":["containers/raycaster and mouse event/index.js"],"sourcesContent":["import React from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\";\r\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader.js\";\r\n\r\nexport default class raycasterAndMouseEvent extends React.Component {\r\n    componentDidMount() {\r\n        this.initThree();\r\n    }\r\n\r\n    initThree = () => {\r\n        // Canvas\r\n        const canvas = document.querySelector(\"canvas.webgl\");\r\n        // Scene\r\n        const scene = new THREE.Scene();\r\n\r\n        /**\r\n         * Objects\r\n         */\r\n        const object1 = new THREE.Mesh(\r\n            new THREE.SphereGeometry(0.5, 16, 16),\r\n            new THREE.MeshBasicMaterial({ color: \"#ff0000\" })\r\n        );\r\n        object1.position.x = -2;\r\n\r\n        const object2 = new THREE.Mesh(\r\n            new THREE.SphereGeometry(0.5, 16, 16),\r\n            new THREE.MeshBasicMaterial({ color: \"#ff0000\" })\r\n        );\r\n\r\n        const object3 = new THREE.Mesh(\r\n            new THREE.SphereGeometry(0.5, 16, 16),\r\n            new THREE.MeshBasicMaterial({ color: \"#ff0000\" })\r\n        );\r\n        object3.position.x = 2;\r\n\r\n        scene.add(object1, object2, object3);\r\n\r\n        /* \r\n        Raycaster\r\n        */\r\n        const raycaster = new THREE.Raycaster();\r\n\r\n        /**\r\n         * Sizes\r\n         */\r\n        const sizes = {\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n        };\r\n\r\n        window.addEventListener(\"resize\", () => {\r\n            // Update sizes\r\n            sizes.width = window.innerWidth;\r\n            sizes.height = window.innerHeight;\r\n\r\n            // Update camera\r\n            camera.aspect = sizes.width / sizes.height;\r\n            camera.updateProjectionMatrix();\r\n\r\n            // Update renderer\r\n            renderer.setSize(sizes.width, sizes.height);\r\n            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n        });\r\n\r\n        /* \r\n        Cursor\r\n        */\r\n        const mouse = new THREE.Vector2()\r\n\r\n        window.addEventListener(\"mousemove\", (event) => {\r\n            /**\r\n             * mouse.x & mouse.y = -1 ~ 1\r\n             */\r\n            mouse.x = event.clientX / sizes.width * 2 - 1\r\n            mouse.y = - (event.clientY / sizes.height * 2 - 1)\r\n            /**\r\n             * we will cast ray in the tick function instead of mousemove event handler function,\r\n             * because mousemove event is fired more frequently than tick function\r\n             */\r\n        })\r\n\r\n        window.addEventListener(\"click\", (event) => {\r\n            if (currentIntersect) {\r\n                switch (currentIntersect.object) {\r\n                    case object1:\r\n                        console.log(\"clicked object1\");\r\n                        break;\r\n                    case object2:\r\n                        console.log(\"clicked object2\");\r\n                        break;\r\n                    case object3:\r\n                        console.log(\"clicked object3\");\r\n                        break;\r\n                }\r\n            }\r\n        })\r\n\r\n        /**\r\n         * Camera\r\n         */\r\n        // Base camera\r\n        const camera = new THREE.PerspectiveCamera(\r\n            75,\r\n            sizes.width / sizes.height,\r\n            0.1,\r\n            100\r\n        );\r\n        camera.position.z = 3;\r\n        scene.add(camera);\r\n\r\n        // Controls\r\n        const controls = new OrbitControls(camera, canvas);\r\n        controls.enableDamping = true;\r\n\r\n        /**\r\n         * Renderer\r\n         */\r\n        const renderer = new THREE.WebGLRenderer({\r\n            canvas: canvas,\r\n        });\r\n        renderer.setSize(sizes.width, sizes.height);\r\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n\r\n        /* \r\n        Model\r\n        */\r\n        const gltfLoader = new GLTFLoader()\r\n        let model = null;\r\n        gltfLoader.load(\r\n            \"./models/Duck/glTF-Binary/Duck.glb\",\r\n            (gltf) => {\r\n                model = gltf.scene\r\n                model.position.y = -1.2\r\n                scene.add(model)\r\n            }\r\n        )\r\n        /* \r\n        Lights\r\n        */\r\n        const ambientLight = new THREE.AmbientLight(\"#ffffff\", 0.3)\r\n        scene.add(ambientLight)\r\n\r\n        const directionalLight = new THREE.DirectionalLight(\"#ffffff\", 0.7)\r\n        directionalLight.position.set(1, 2, 3)\r\n        scene.add(directionalLight)\r\n        /**\r\n         * Animate\r\n         */\r\n        const clock = new THREE.Clock();\r\n\r\n        let currentIntersect = null;\r\n\r\n        const tick = () => {\r\n            const elapsedTime = clock.getElapsedTime()\r\n\r\n            // animate objects\r\n            object1.position.y = Math.sin(elapsedTime * 0.3) * 1.5\r\n            object2.position.y = Math.sin(elapsedTime * 0.8) * 1.5\r\n            object3.position.y = Math.sin(elapsedTime * 1.4) * 1.5\r\n\r\n            // cast a ray\r\n            // const rayOrigin = new THREE.Vector3(-3, 0, 0);\r\n            // const rayDirection = new THREE.Vector3(1, 0, 0)\r\n            // rayDirection.normalize()\r\n            // raycaster.set(rayOrigin, rayDirection);\r\n            raycaster.setFromCamera(mouse, camera)\r\n\r\n            const objectsToTest = [object1, object2, object3]\r\n            const intersects = raycaster.intersectObjects(objectsToTest)\r\n\r\n            for (const object of objectsToTest) {\r\n                object.material.color.set(\"#ff0000\")\r\n            }\r\n\r\n            for (const intersect of intersects) {\r\n                intersect.object.material.color.set(\"#0000ff\")\r\n            }\r\n\r\n            if (intersects.length) {\r\n                if (currentIntersect == null) {\r\n                    console.log(\"mouse enter\");\r\n                }\r\n                currentIntersect = intersects[0];\r\n            }\r\n            else {\r\n                if (currentIntersect) {\r\n                    console.log(\"mouse leave\");\r\n\r\n                }\r\n                currentIntersect = null;\r\n            }\r\n\r\n            // Test intersect with model\r\n            if (model) {\r\n                const modelIntersects = raycaster.intersectObject(model);\r\n                if (modelIntersects.length) {\r\n                    model.scale.set(1.2, 1.2, 1.2);\r\n                }\r\n                else {\r\n                    model.scale.set(1, 1, 1)\r\n                }\r\n            }\r\n\r\n            // update controls\r\n            controls.update()\r\n\r\n            // Renderer\r\n            renderer.render(scene, camera)\r\n\r\n            // Call tick again on the next frame\r\n            window.requestAnimationFrame(tick)\r\n        }\r\n        tick()\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <canvas className=\"webgl\"></canvas>\r\n        )\r\n    }\r\n}"],"names":["raycasterAndMouseEvent","React","constructor","arguments","initThree","canvas","document","querySelector","scene","THREE","object1","color","position","x","object2","object3","add","raycaster","sizes","width","window","innerWidth","height","innerHeight","addEventListener","camera","aspect","updateProjectionMatrix","renderer","setSize","setPixelRatio","Math","min","devicePixelRatio","mouse","event","clientX","y","clientY","currentIntersect","object","console","log","z","controls","OrbitControls","enableDamping","gltfLoader","GLTFLoader","model","load","gltf","ambientLight","directionalLight","set","clock","tick","elapsedTime","getElapsedTime","sin","setFromCamera","objectsToTest","intersects","intersectObjects","material","intersect","length","intersectObject","scale","update","render","requestAnimationFrame","componentDidMount","this","_jsx","className"],"sourceRoot":""}